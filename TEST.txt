from fastapi import FastAPI
from fastapi.responses import StreamingResponse
from io import BytesIO
import subprocess

app = FastAPI()

def get_fps(video_bytes: bytes) -> float:
    """
    ffprobe を使って動画の FPS を取得する
    video_bytes を pipe 経由で ffprobe に渡す
    """
    cmd = [
        "ffprobe", "-v", "0",
        "-of", "csv=p=0",
        "-select_streams", "v:0",
        "-show_entries", "stream=r_frame_rate",
        "pipe:0"
    ]
    result = subprocess.run(
        cmd,
        input=video_bytes,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    fps_str = result.stdout.decode().strip()  # 例: "30/1" や "30000/1001"
    if "/" in fps_str:
        num, den = map(int, fps_str.split("/"))
        return num / den if den != 0 else 0.0
    return float(fps_str)


@app.get("/snapshot/{filename}")
def snapshot(filename: str, frame: int = 0):
    """
    MinIO から取得した動画から指定フレームを切り出して返す
    - frame: フレーム番号（0 始まり）
    """
    # 1. MinIO から動画データを取得
    video_bytes = b"".join(stream_minio(filename))  # stream_minio は既存の関数

    # 2. fps を取得してフレーム番号を秒に変換
    fps = get_fps(video_bytes)
    seconds = frame / fps if fps > 0 else 0.0

    # 3. ffmpeg コマンドを構築
    cmd = [
        "ffmpeg",
        "-ss", str(seconds),   # 秒単位で指定
        "-i", "pipe:0",
        "-frames:v", "1",
        "-f", "image2",
        "pipe:1"
    ]

    # 4. ffmpeg を実行
    process = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    out, err = process.communicate(input=video_bytes)

    # 5. JPEG 画像として返す
    return StreamingResponse(BytesIO(out), media_type="image/jpeg")
